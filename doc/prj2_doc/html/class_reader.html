<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA_prj2: Reader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA_prj2<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_reader-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Reader Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class for reading and parsing various types of graph data.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="reader_8h_source.html">reader.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_reader_1_1_coordinates.html">Coordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold latitude and longitude coordinates.  <a href="struct_reader_1_1_coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5240a5b7560d240dfb61067e23c60019" id="r_a5240a5b7560d240dfb61067e23c60019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5240a5b7560d240dfb61067e23c60019">readAndParseStadium</a> ()</td></tr>
<tr class="memdesc:a5240a5b7560d240dfb61067e23c60019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a graph representing stadium data.  <br /></td></tr>
<tr class="separator:a5240a5b7560d240dfb61067e23c60019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1f023060c35cbd4ef7f9ed7cdb1824" id="r_a7c1f023060c35cbd4ef7f9ed7cdb1824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c1f023060c35cbd4ef7f9ed7cdb1824">readAndParseShipping</a> ()</td></tr>
<tr class="memdesc:a7c1f023060c35cbd4ef7f9ed7cdb1824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a graph representing shipping data.  <br /></td></tr>
<tr class="separator:a7c1f023060c35cbd4ef7f9ed7cdb1824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3d0fa678c9f44327a2412bd6888859" id="r_a8a3d0fa678c9f44327a2412bd6888859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a3d0fa678c9f44327a2412bd6888859">readAndParse4_2Extra_Fully_Connected_Graphs</a> (<a class="el" href="class_edge.html">const</a> std::string <a class="el" href="class_edge.html">filename</a>, std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">vertexMap</a>, std::unordered_map&lt; std::string, <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">edgeMap</a>)</td></tr>
<tr class="memdesc:a8a3d0fa678c9f44327a2412bd6888859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a graph and makes it fully connected.  <br /></td></tr>
<tr class="separator:a8a3d0fa678c9f44327a2412bd6888859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb78d8212144696b4fda4902e74ba24b" id="r_abb78d8212144696b4fda4902e74ba24b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb78d8212144696b4fda4902e74ba24b">readAndParseRealWorld_Graphs4_2</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">graphNumber</a>, std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">vertexMap</a>, std::unordered_map&lt; std::string, <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">edgeMap</a>)</td></tr>
<tr class="memdesc:abb78d8212144696b4fda4902e74ba24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a real-world graph from a file based on the specified graph number. In this specific parsing, we are using 2 unordered maps, one for vertex's and the other for edges, this prevent the exhaustive search that was being performed in the find vertex and addEgde, methods. We also discard those functions to meet the performance requirements, creating new ones, that are more efficient, receiving the objects instead of searching them.  <br /></td></tr>
<tr class="separator:abb78d8212144696b4fda4902e74ba24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efc52d2a040e99581c20f9167d6d154" id="r_a2efc52d2a040e99581c20f9167d6d154"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="struct_reader_1_1_coordinates.html">Coordinates</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2efc52d2a040e99581c20f9167d6d154">readCoordinates</a> ()</td></tr>
<tr class="memdesc:a2efc52d2a040e99581c20f9167d6d154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads coordinates from a CSV file.  <br /></td></tr>
<tr class="separator:a2efc52d2a040e99581c20f9167d6d154"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5e147ae7cfda1ba1e03e6d8f0704ce8a" id="r_a5e147ae7cfda1ba1e03e6d8f0704ce8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">static</a> <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e147ae7cfda1ba1e03e6d8f0704ce8a">readAndParseTourism</a> ()</td></tr>
<tr class="memdesc:a5e147ae7cfda1ba1e03e6d8f0704ce8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a graph representing tourism data.  <br /></td></tr>
<tr class="separator:a5e147ae7cfda1ba1e03e6d8f0704ce8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffdee1e47517331abafa9f765d5e9e2" id="r_a5ffdee1e47517331abafa9f765d5e9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">static</a> <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ffdee1e47517331abafa9f765d5e9e2">readAndParseRealWorld_Graphs</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">graphNumber</a>, std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">vertexMap</a>, std::unordered_map&lt; std::string, <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">edgeMap</a>)</td></tr>
<tr class="memdesc:a5ffdee1e47517331abafa9f765d5e9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a real-world graph from a file based on the specified graph number. In this specific parsing, we are using 2 unordered maps, one for vertex's and the other for edges, this prevent the exhaustive search that was being performed in the find vertex and addEgde, methods. We also discard those functions to meet the performance requirements, creating new ones, that are more efficient, receiving the objects instead of searching them.  <br /></td></tr>
<tr class="separator:a5ffdee1e47517331abafa9f765d5e9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3bf4be0b4feda159512cb5cfc662d3" id="r_a9b3bf4be0b4feda159512cb5cfc662d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">static</a> <a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b3bf4be0b4feda159512cb5cfc662d3">convert_to_radians</a> (<a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">coord</a>)</td></tr>
<tr class="memdesc:a9b3bf4be0b4feda159512cb5cfc662d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts degrees to radians.  <br /></td></tr>
<tr class="separator:a9b3bf4be0b4feda159512cb5cfc662d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8c5189f5698346b3f76bd3b7561d41" id="r_aef8c5189f5698346b3f76bd3b7561d41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">static</a> <a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef8c5189f5698346b3f76bd3b7561d41">Haversine</a> (<a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">lat1</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">lon1</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">lat2</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">lon2</a>)</td></tr>
<tr class="memdesc:aef8c5189f5698346b3f76bd3b7561d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Haversine distance between two points given their coordinates.  <br /></td></tr>
<tr class="separator:aef8c5189f5698346b3f76bd3b7561d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbb51de5e1f94e242ffdfdd72cdf7a3" id="r_accbb51de5e1f94e242ffdfdd72cdf7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">static</a> std::vector&lt; std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accbb51de5e1f94e242ffdfdd72cdf7a3">kMeansClustering</a> (<a class="el" href="class_edge.html">const</a> <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="class_edge.html">graph</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">k</a>, <a class="el" href="class_edge.html">const</a> std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="struct_reader_1_1_coordinates.html">Coordinates</a> &gt; &amp;<a class="el" href="class_edge.html">coordinates</a>)</td></tr>
<tr class="memdesc:accbb51de5e1f94e242ffdfdd72cdf7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs k-means clustering on a graph based on geographical coordinates.  <br /></td></tr>
<tr class="separator:accbb51de5e1f94e242ffdfdd72cdf7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accca31daccce6266ec7d283d80622f61" id="r_accca31daccce6266ec7d283d80622f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">static</a> std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="struct_reader_1_1_coordinates.html">Reader::Coordinates</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accca31daccce6266ec7d283d80622f61">readCoordinatesRealWorldGraph</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">type</a>)</td></tr>
<tr class="separator:accca31daccce6266ec7d283d80622f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for reading and parsing various types of graph data. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b3bf4be0b4feda159512cb5cfc662d3" name="a9b3bf4be0b4feda159512cb5cfc662d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3bf4be0b4feda159512cb5cfc662d3">&#9670;&#160;</a></span>convert_to_radians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> Reader::convert_to_radians </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>coord</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts degrees to radians. </p>
<p>Converts a coordinate from degrees to radians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>The coordinate value in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate value in radians.</dd></dl>
<p>This function takes a coordinate in degrees and converts it to radians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>The coordinate in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The coordinate in radians. </dd></dl>

</div>
</div>
<a id="aef8c5189f5698346b3f76bd3b7561d41" name="aef8c5189f5698346b3f76bd3b7561d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8c5189f5698346b3f76bd3b7561d41">&#9670;&#160;</a></span>Haversine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> Reader::Haversine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lat1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lon1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lat2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lon2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Haversine distance between two points given their coordinates. </p>
<p>Calculates the Haversine distance between two points given their latitude and longitude.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat1</td><td>Latitude of the first point. </td></tr>
    <tr><td class="paramname">lon1</td><td>Longitude of the first point. </td></tr>
    <tr><td class="paramname">lat2</td><td>Latitude of the second point. </td></tr>
    <tr><td class="paramname">lon2</td><td>Longitude of the second point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Haversine distance between the two points.</dd></dl>
<p>This function computes the Haversine distance between two points on the Earth's surface, specified by their latitude and longitude in degrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat1</td><td>Latitude of the first point in degrees. </td></tr>
    <tr><td class="paramname">lon1</td><td>Longitude of the first point in degrees. </td></tr>
    <tr><td class="paramname">lat2</td><td>Latitude of the second point in degrees. </td></tr>
    <tr><td class="paramname">lon2</td><td>Longitude of the second point in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The Haversine distance between the two points in meters. </dd></dl>

</div>
</div>
<a id="accbb51de5e1f94e242ffdfdd72cdf7a3" name="accbb51de5e1f94e242ffdfdd72cdf7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbb51de5e1f94e242ffdfdd72cdf7a3">&#9670;&#160;</a></span>kMeansClustering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; Reader::kMeansClustering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>k</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="struct_reader_1_1_coordinates.html">Coordinates</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coordinates</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs k-means clustering on a graph based on geographical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to cluster. </td></tr>
    <tr><td class="paramname">k</td><td>The number of clusters. </td></tr>
    <tr><td class="paramname">coordinates</td><td>A map containing node IDs and their coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of clusters, where each cluster is represented by a vector of node IDs. </dd></dl>

</div>
</div>
<a id="a8a3d0fa678c9f44327a2412bd6888859" name="a8a3d0fa678c9f44327a2412bd6888859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3d0fa678c9f44327a2412bd6888859">&#9670;&#160;</a></span>readAndParse4_2Extra_Fully_Connected_Graphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; Reader::readAndParse4_2Extra_Fully_Connected_Graphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexMap</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edgeMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and parses a graph and makes it fully connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename of the graph data. </td></tr>
    <tr><td class="paramname">vertexMap</td><td>A map containing vertex IDs and pointers to vertex objects. </td></tr>
    <tr><td class="paramname">edgeMap</td><td>A map containing edge keys and pointers to edge objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A fully connected graph. </dd></dl>

</div>
</div>
<a id="a5ffdee1e47517331abafa9f765d5e9e2" name="a5ffdee1e47517331abafa9f765d5e9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffdee1e47517331abafa9f765d5e9e2">&#9670;&#160;</a></span>readAndParseRealWorld_Graphs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; Reader::readAndParseRealWorld_Graphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>graphNumber</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexMap</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edgeMap</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads and parses a real-world graph from a file based on the specified graph number. In this specific parsing, we are using 2 unordered maps, one for vertex's and the other for edges, this prevent the exhaustive search that was being performed in the find vertex and addEgde, methods. We also discard those functions to meet the performance requirements, creating new ones, that are more efficient, receiving the objects instead of searching them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphNumber</td><td>The number of the graph to read and parse. </td></tr>
    <tr><td class="paramname">vertexMap</td><td>A map containing vertex IDs and pointers to vertex objects. </td></tr>
    <tr><td class="paramname">edgeMap</td><td>A map containing edge keys and pointers to edge objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A real-world graph. </dd></dl>

</div>
</div>
<a id="abb78d8212144696b4fda4902e74ba24b" name="abb78d8212144696b4fda4902e74ba24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb78d8212144696b4fda4902e74ba24b">&#9670;&#160;</a></span>readAndParseRealWorld_Graphs4_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; Reader::readAndParseRealWorld_Graphs4_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>graphNumber</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexMap</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edgeMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and parses a real-world graph from a file based on the specified graph number. In this specific parsing, we are using 2 unordered maps, one for vertex's and the other for edges, this prevent the exhaustive search that was being performed in the find vertex and addEgde, methods. We also discard those functions to meet the performance requirements, creating new ones, that are more efficient, receiving the objects instead of searching them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphNumber</td><td>The number of the graph to read and parse. </td></tr>
    <tr><td class="paramname">vertexMap</td><td>A map containing vertex IDs and pointers to vertex objects. </td></tr>
    <tr><td class="paramname">edgeMap</td><td>A map containing edge keys and pointers to edge objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A real-world graph. </dd></dl>

</div>
</div>
<a id="a7c1f023060c35cbd4ef7f9ed7cdb1824" name="a7c1f023060c35cbd4ef7f9ed7cdb1824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1f023060c35cbd4ef7f9ed7cdb1824">&#9670;&#160;</a></span>readAndParseShipping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; Reader::readAndParseShipping </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and parses a graph representing shipping data. </p>
<dl class="section return"><dt>Returns</dt><dd>A graph representing shipping data. </dd></dl>

</div>
</div>
<a id="a5240a5b7560d240dfb61067e23c60019" name="a5240a5b7560d240dfb61067e23c60019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5240a5b7560d240dfb61067e23c60019">&#9670;&#160;</a></span>readAndParseStadium()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; Reader::readAndParseStadium </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and parses a graph representing stadium data. </p>
<dl class="section return"><dt>Returns</dt><dd>A graph representing stadium data. </dd></dl>

</div>
</div>
<a id="a5e147ae7cfda1ba1e03e6d8f0704ce8a" name="a5e147ae7cfda1ba1e03e6d8f0704ce8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e147ae7cfda1ba1e03e6d8f0704ce8a">&#9670;&#160;</a></span>readAndParseTourism()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; Reader::readAndParseTourism </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads and parses a graph representing tourism data. </p>
<dl class="section return"><dt>Returns</dt><dd>A graph representing tourism data. </dd></dl>

</div>
</div>
<a id="a2efc52d2a040e99581c20f9167d6d154" name="a2efc52d2a040e99581c20f9167d6d154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efc52d2a040e99581c20f9167d6d154">&#9670;&#160;</a></span>readCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="struct_reader_1_1_coordinates.html">Reader::Coordinates</a> &gt; Reader::readCoordinates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads coordinates from a CSV file. </p>
<dl class="section return"><dt>Returns</dt><dd>A map containing node IDs and their corresponding coordinates. </dd></dl>

</div>
</div>
<a id="accca31daccce6266ec7d283d80622f61" name="accca31daccce6266ec7d283d80622f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accca31daccce6266ec7d283d80622f61">&#9670;&#160;</a></span>readCoordinatesRealWorldGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="struct_reader_1_1_coordinates.html">Reader::Coordinates</a> &gt; Reader::readCoordinatesRealWorldGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/rebel/Desktop/DA2.0-main/<a class="el" href="reader_8h_source.html">reader.h</a></li>
<li>C:/Users/rebel/Desktop/DA2.0-main/<a class="el" href="reader_8cpp.html">reader.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
